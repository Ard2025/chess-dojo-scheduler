package database

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/expression"
	"github.com/jackstenglein/chess-dojo-scheduler/backend/api/errors"
)

type NotificationType string

const (
	// Notifications generated by comments on a game
	NotificationType_GameComment NotificationType = "GAME_COMMENT"

	// Notifications generated by getting a new follower
	NotificationType_NewFollower NotificationType = "NEW_FOLLOWER"

	// Notifications generated by comments on a timeline entry
	NotificationType_TimelineComment NotificationType = "TIMELINE_COMMENT"
)

// Data for a notification
type Notification struct {
	// The username of the user that this notification applies to
	Username string `dynamodbav:"username" json:"-"`

	// The id of the notification. It can take various forms depending
	// on the type of notification.
	Id string `dynamodbav:"id" json:"id"`

	// The type of the notification
	Type NotificationType `dynamodbav:"type" json:"type"`

	// The time the notification was last updated
	UpdatedAt string `dynamodbav:"updatedAt" json:"updatedAt"`

	// The number of unread instances of this notification
	Count int `dynamodbav:"count" json:"count"`

	// Metadata for a game comment notification
	GameCommentMetadata *GameCommentMetadata `dynamodbav:"gameCommentMetadata,omitempty" json:"gameCommentMetadata,omitempty"`

	// Metadata for a new follower notification
	NewFollowerMetadata *NewFollowerMetadata `dynamodbav:"newFollowerMetadata,omitempty" json:"newFollowerMetadata,omitempty"`

	// Metadata for a timeline comment notification
	TimelineCommentMetadata *TimelineCommentMetadata `dynamodbav:"timelineCommentMetadata,omitempty" json:"timelineCommentMetadata,omitempty"`
}

// Metadata for a game comment notification.
type GameCommentMetadata struct {
	// The cohort of the game
	Cohort DojoCohort `dynamodbav:"cohort" json:"cohort"`

	// The sort key of the game
	Id string `dynamodbav:"id" json:"id"`

	// The headers of the game
	Headers map[string]string `dynamodbav:"headers" json:"headers"`
}

// Metadata for a new follower notification.
type NewFollowerMetadata struct {
	// The username of the follower
	Username string `dynamodbav:"username" json:"username"`

	// The display name of the follower
	DisplayName string `dynamodbav:"displayName" json:"displayName"`

	// The cohort of the follower
	Cohort DojoCohort `dynamodbav:"cohort" json:"cohort"`
}

// Metadata for a timeline comment notification.
type TimelineCommentMetadata struct {
	// The owner of the timeline entry
	Owner string `dynamodbav:"owner" json:"owner"`

	// The id of the timeline entry
	Id string `dynamodbav:"id" json:"id"`

	// The requirement name of the timeline entry
	Name string `dynamodbav:"name" json:"name"`
}

type NotificationPutter interface {
	// PutNotification inserts the provided notification into the database.
	PutNotification(n *Notification) error
}

// GameCommentNotification returns a Notification object for a game comment.
func GameCommentNotification(g *Game) *Notification {
	if g == nil {
		return nil
	}

	return &Notification{
		Username:  g.Owner,
		Id:        fmt.Sprintf("%s|%s|%s", NotificationType_GameComment, g.Cohort, g.Id),
		Type:      NotificationType_GameComment,
		UpdatedAt: time.Now().Format(time.RFC3339),
		GameCommentMetadata: &GameCommentMetadata{
			Cohort:  g.Cohort,
			Id:      g.Id,
			Headers: g.Headers,
		},
	}
}

// NewFollowerNotification returns a Notification object for a follower entry.
func NewFollowerNotification(f *FollowerEntry, cohort DojoCohort) *Notification {
	return &Notification{
		Username:  f.Poster,
		Id:        fmt.Sprintf("%s|%s", NotificationType_NewFollower, f.Follower),
		Type:      NotificationType_NewFollower,
		UpdatedAt: time.Now().Format(time.RFC3339),
		NewFollowerMetadata: &NewFollowerMetadata{
			Username:    f.Follower,
			DisplayName: f.FollowerDisplayName,
			Cohort:      cohort,
		},
	}
}

// TimelineCommentNotification returns a Notification object for a timeline entry.
func TimelineCommentNotification(e *TimelineEntry) *Notification {
	return &Notification{
		Username:  e.Owner,
		Id:        fmt.Sprintf("%s|%s|%s", NotificationType_TimelineComment, e.Owner, e.Id),
		Type:      NotificationType_TimelineComment,
		UpdatedAt: time.Now().Format(time.RFC3339),
		TimelineCommentMetadata: &TimelineCommentMetadata{
			Owner: e.Owner,
			Id:    e.Id,
			Name:  e.RequirementName,
		},
	}
}

// PutNotification inserts the provided notification into the database.
func (repo *dynamoRepository) PutNotification(n *Notification) error {
	update := expression.
		Set(expression.Name("type"), expression.Value(n.Type)).
		Set(expression.Name("updatedAt"), expression.Value(n.UpdatedAt)).
		Add(expression.Name("count"), expression.Value(1))

	if n.GameCommentMetadata != nil {
		update.Set(expression.Name("gameCommentMetadata"), expression.Value(n.GameCommentMetadata))
	}
	if n.NewFollowerMetadata != nil {
		update.Set(expression.Name("newFollowerMetadata"), expression.Value(n.NewFollowerMetadata))
	}
	if n.TimelineCommentMetadata != nil {
		update.Set(expression.Name("timelineCommentMetadata"), expression.Value(n.TimelineCommentMetadata))
	}

	expr, err := expression.NewBuilder().WithUpdate(update).Build()
	if err != nil {
		return errors.Wrap(500, "Temporary server error", "Unable to build update expression", err)
	}

	input := &dynamodb.UpdateItemInput{
		Key: map[string]*dynamodb.AttributeValue{
			"username": {S: aws.String(n.Username)},
			"id":       {S: aws.String(n.Id)},
		},
		UpdateExpression:          expr.Update(),
		ExpressionAttributeNames:  expr.Names(),
		ExpressionAttributeValues: expr.Values(),
		TableName:                 &notificationTable,
	}

	_, err = repo.svc.UpdateItem(input)
	return errors.Wrap(500, "Temporary server error", "DynamoDB UpdateItem failure", err)

	// item, err := dynamodbattribute.MarshalMap(n)
	// if err != nil {
	// 	return errors.Wrap(500, "Temporary server error", "Unable to marshal notification", err)
	// }

	// input := &dynamodb.PutItemInput{
	// 	Item:      item,
	// 	TableName: aws.String(notificationTable),
	// }
	// _, err = repo.svc.PutItem(input)
	// return errors.Wrap(500, "Temporary server error", "DynamoDB PutItem failure", err)
}

// ListNotifications returns a list of notifications for the provided username.
func (repo *dynamoRepository) ListNotifications(username string, startKey string) ([]Notification, string, error) {
	input := &dynamodb.QueryInput{
		KeyConditionExpression: aws.String("#username = :username"),
		ExpressionAttributeNames: map[string]*string{
			"#username": aws.String("username"),
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			":username": {
				S: aws.String(username),
			},
		},
		ScanIndexForward: aws.Bool(false),
		TableName:        aws.String(notificationTable),
	}

	var notifications []Notification
	lastKey, err := repo.query(input, startKey, &notifications)
	if err != nil {
		return nil, "", err
	}
	return notifications, lastKey, nil
}

// DeleteNotification removes the notification with the specified key from the database.
func (repo *dynamoRepository) DeleteNotification(username, id string) error {
	input := &dynamodb.DeleteItemInput{
		Key: map[string]*dynamodb.AttributeValue{
			"username": {S: aws.String(username)},
			"id":       {S: aws.String(id)},
		},
		TableName: aws.String(notificationTable),
	}

	_, err := repo.svc.DeleteItem(input)
	return errors.Wrap(500, "Temporary server error", "Failed Dynamo DeleteItem call", err)
}
